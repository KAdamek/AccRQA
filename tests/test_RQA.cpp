#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <vector>
#include <limits>

using namespace std;

#include <dirent.h>

#include "../include/AccRQA_library.hpp"

typedef float RQAdp;

bool DEBUG_MODE = false;
bool CHECK = true;
bool GPU_UNIT_TEST = true;
bool CPU_UNIT_TEST = true;

double test_timeseries[1122] = {-2.877835553380526, -3.1337896208440412, -3.384812675562828, -3.630262052920739, -3.8694901314953976, -4.101848029900422, -4.326689062086969, -4.543371930229045, -4.751263660252141, -4.949742294637757, -5.138199371558287, -5.316042219128137, -5.482696090542416, -5.637606170057956, -5.780239462353633, -5.910086587894296, -6.026663491548971, -6.129513075291892, -6.21820676211385, -6.292345984783618, -6.351563587008422, -6.395525199420916, -6.423930510726906, -6.436514472112707, -6.4330484187994905, -6.413341150915059, -6.377239857307018, -6.3246310281276585, -6.255441225174401, -6.169637770170224, -6.067229464604506, -5.948266944754392, -5.812843187817898, -5.6610938065859235, -5.493197262877345, -5.30937497456952, -5.109891326409792, -4.895053558575065, -4.665211561277801, -4.420757562393521, -4.162125706575202, -3.889791530445951, -3.604271331206339, -3.306121417984764, -2.995937297329922, -2.6743527263323212, -2.3420386871740675, -1.999702265454103, -1.6480854437732884, -1.2879638162009015, -0.9201452293963259, -0.5454683626319177, -0.16480125598321388, 0.22096019833902428, 0.610893784297686, 1.0040524883275235, 1.3994659964532006, 1.7961421279655565, 2.1930681623990442, 2.5892120064977595, 2.9835231166170026, 3.3749331096575337, 3.762355913207642, 4.144687315683657, 4.520803692545646, 4.88955965151821, 5.249784216278463, 5.600275083867297, 5.9397902919810734, 6.267036505983423, 6.580652790922446, 6.879188468093474, 7.161073236591997, 7.42457726238411, 7.667758486169493, 7.888393922169073, 8.083891530967916, 8.251179649017342, 8.386572546159098, 8.48561437807485, 8.542911355025211, 8.551975108480606, 8.50512143648463, 8.393498940865774, 8.207359061980819, 7.936711173764928, 7.57250828001011, 7.108437672878881, 6.543201334691503, 5.882856514372287, 5.142446311994078, 4.346010947888825, 3.52439084678997, 2.711042397252199, 1.9370095919186907, 1.2266308141487066, 0.5951904644636439, 0.0488186321213903, -0.41390485159971024, -0.7995569680978298, -1.1174958302559257, -1.3779711595020288, -1.5908612982832695, -1.764971471393415, -1.9077457787030054, -2.0252421437441464, -2.1222508813406797, -2.2024756991603462, -2.268728148510987, -2.3231094706928883, -2.36716834373126, -2.402031477689877, -2.42850837382432, -2.447173497297246, -2.458429677250325, -2.4625564073790245, -2.4597463030883953, -2.4501323882272037, -2.433808407844721, -2.410843866436517, -2.3812951173256725, -2.3452135128173532, -2.302651371337635, -2.253666333917807, -2.198324530710183, -2.136702870340018, -2.0688906782884127, -1.9949908551920046, -1.915120673863417, -1.8294123051756148, -1.7380131365604141, -1.6410859283729526, -1.538808842875787, -1.4313753690907918, -1.3189941615252512, -1.201888804962692, -1.080297514722963, -0.9544727797207153, -0.8246809538776145, -0.6912017969837367, -0.5543279716111025, -0.4143644967380672, -0.2716281605091045, -0.12644690148841545, 0.020840861068335034, 0.16988692394921107, 0.3203340272951599, 0.4718166164731489, 0.623961638028225, 0.7763893610936704, 0.928714226215918, 1.0805457073974873, 1.2314892316341632, 1.381147082244752, 1.5291193431732149, 1.6750048666089796, 1.8184022410296274, 1.9589107923518556, 2.0961315970490086, 2.2296685012863398, 2.3591291685806515, 2.4841261332631586, 2.6042778645430555, 2.7192098570191505, 2.8285557248923383, 2.9319583099702284, 3.0290708233394392, 3.1195579825992192, 3.203097178102709, 3.2793796573366425, 3.348111727110258, 3.4090159758034377, 3.4618325108276404, 3.5063202118915044, 3.542257988768943, 3.5694460518767364, 3.587707162199396, 3.5968878643348994, 3.596859677656756, 3.5875202331521683, 3.5687943082860474, 3.5406347651564882, 3.503023330783282, 3.4559712011612036, 3.399519433022511, 3.3337390846584936, 3.258731122637148, 3.1746259467196167, 3.0815827281202863, 2.979788371739159, 2.8694562142230358, 2.750824464663244, 2.6241544310551363, 2.4897285894576964, 2.3478485666005118, 2.1988331029801986, 2.0430160868979472, 1.8807447211481982, 1.7123778957880653, 1.538284817978327, 1.358843935218599, 1.1744421679001955, 0.9854744456093519, 0.7923435219327986, 0.5954600240712339, 0.3952426798135597, 0.19211865500720293, -0.013476068085158874, -0.2210963414456196, -0.4302875881629209, -0.6405856838238402, -0.851517020322456, -1.0625987770484755, -1.2733393861988649, -1.4832392441720597, -1.691791600790999, -1.8984836335479842, -2.102797683340795, -2.3042126066543274, -2.502205228266233, -2.696251867057019, -2.8858299017076026, -3.0704193647125733, -3.249504541930825, -3.4225755670669087, -3.589130000438945, -3.748674383728328, -3.900725767525734, -4.044813206629545, -4.1804792208363475, -4.307281220933449, -4.424792896016922, -4.532605564266868, -4.6303294820235585, -4.717595112228141, -4.794054349213558, -4.859381698535334, -4.913275409260138, -4.955458556474998, -4.985680071664183, -5.003715715493565, -5.009369004608424, -5.00247206129492, -4.98288641349479, -4.950503727893524, -4.9052464715522, -4.84706850573737, -4.7759556117908755, -4.691925933161535, -4.595030378979592, -4.485352900560228, -4.363010660893743, -4.228154259663892, -4.0809677352929565, -3.9216685672423854, -3.7505075524255136, -3.567768617426882, -3.3737685457679523, -3.1688566203992434, -2.953414183106185, -2.727854115210331, -2.492620224665506, -2.2481865721446113, -1.9950567037335758, -1.73376281263903, -1.4648648286580839, -1.188949433667998, -0.906629015528011, -0.6185405523233171, -0.3253444441773049, -0.02772329121137901, 0.27361937334442277, 0.5779603877588202, 0.8845582912695895, 1.1926546764345896, 1.5014755398003319, 1.810232623613792, 2.1181247295931582, 2.424338976413103, 2.728051986297644, 3.028430961626979, 3.324634616101114, 3.6158139188250153, 3.9011125927855446, 4.179667306914751, 4.450607490801512, 4.71305467450982, 4.966121253929645, 5.20890855808776, 5.440504081084468, 5.65997774017662, 5.866376977606197, 6.058720574838539, 6.2359910685683735, 6.3971256387080295, 6.541005544705949, 6.666444291217055, 6.772175009012747, 6.856837899665399, 6.918969208303252, 6.956993890940399, 6.969225149825256, 6.953875043551559, 6.909081612202988, 6.832958746572012, 6.723675434958177, 6.5795699826495495, 6.399301898679718, 6.182038694621885, 5.927666478682895, 5.637002694668903, 5.311978632767643, 4.955752130845918, 4.572710777304453, 4.1683372545770645, 3.7489309284624377, 3.32120949752998, 2.8918431375307745, 2.466991316568949, 2.051912765751926, 1.6507017336892664, 1.2661747725185146, 0.8999016602353874, 0.5523503969793853, 0.22310408100718382, -0.08889310627517948, -0.38509599041833115, -0.6671484123255935, -0.9367155511605467, -1.1953616904967426, -1.4444702718622966, -1.685199611652382, -1.9184663653833958, -2.1449489973826377, -2.365104452413225, -2.5791925098379482, -2.7873037062928283, -2.9893878196035666, -3.185280992291436, -3.3747303437900054, -3.557415513349795, -3.732966991403911, -3.900981376296708, -4.061033842965766, -4.212688198874548, -4.355504915534886, -4.489047512285137, -4.612887628481253, -4.726609071768168, -4.829811081739287, -4.922110997013186, -5.003146474646905, -5.072577372756181, -5.1300873783997, -5.1753854426487385, -5.208207059295159, -5.228315423004226, -5.235502481308637, -5.229589893698503, -5.2104299074658105, -5.177906151744133, -5.131934353703964, -5.072462977299264, -4.999473783377246, -4.91298231082995, -4.8130382783336945, -4.69972590419316, -4.573164143253971, -4.43350684091087, -4.280942801673686, -4.11569577138457, -3.938024334909712, -3.74822172465458, -3.5466155435823867, -3.333567400655749, -3.1094724526001905, -2.8747588900236027, -2.6298872877523, -2.3753499150412516, -2.1116699508305667, -1.8394006045323759, -1.5591241820274628, -1.2714510732061757, -0.9770186671966139, -0.6764901850256091, -0.3705534916794224, -0.05991982901463211, 0.2546774935865069, 0.5724844383151124, 0.8927276063689041, 1.2146156174537666, 1.5373404858739794, 1.8600789754540126, 2.1819939126347117, 2.5022354266442344, 2.8199420891982885, 3.134241915732267, 3.4442531744085514, 3.7490849486673326, 4.0478373851788305, 4.3396015215691, 4.623458625825558, 4.8984788758427085, 5.163719260390544, 5.418220499880808, 5.661002776015589, 5.891060051799978, 6.107352664154315, 6.308797978550449, 6.494258779915002, 6.662529228936607, 6.812318291191164, 6.942230788510734, 7.050746612354063, 7.136199345656278, 7.196756324533547, 7.2304035855349325, 7.2349407873899505, 7.207993269914761, 7.1470505876279535, 7.049542720122206, 6.912965893856149, 6.735067820603062, 6.514096716738879, 6.249106776105489, 5.940295901094708, 5.589330576107194, 5.199593855815909, 4.7762831253709095, 4.326294612952748, 3.8578655430686326, 3.379998129107624, 2.9017464926479803, 2.4314877500651715, 1.976304346745133, 1.541574200751837, 1.1308106380564882, 0.7457363940943288, 0.3865336774319178, 0.052194138588627925, -0.25910357403843354, -0.5496432621722123, -0.821880121038009, -1.0782218693150678, -1.320880527589827, -1.5517850765049614, -1.772541840862768, -1.9844292888081279, -2.1884155643687855, -2.3851894017139457, -2.575197465855815, -2.7586832826970373, -2.9357246410218423, -3.106267652496505, -3.270156591023404, -3.4271592702746982, -3.5769881259849026, -3.719317398297813, -3.853796924806454, -3.9800630829250725, -4.0977473983208474, -4.2064832880691885, -4.305911338157874, -4.395683451087921, -4.475466131166208, -4.544943120931744, -4.60381755050148, -4.651813722398903, -4.688678621954655, -4.714183219775639, -4.728123608790057, -4.7303220130511505, -4.720627687337796, -4.6989177205054125, -4.665097756056376, -4.619102631242474, -4.560896940601483, -4.490475524644766, -4.407863883751718, -4.313118517460237, -4.206327188516672, -4.087609111506535, -3.9571150643786837, -3.815027422433885, -3.6615601141986804, -3.4969584991535534, -3.321499166434028, -3.1354896545609288, -2.939268091901141, -2.7332027592048442, -2.5176915737170273, -2.2931614869768167, -2.0600678546668463, -1.8188936425311495, -1.570148651052835, -1.314368620141069, -1.0521142629243663, -0.7839702818960134, -0.5105442761847634, -0.23246560779378309, 0.04961574929441945, 0.3350304738614368, 0.6230911243187132, 0.9130934394633023, 1.2043176510651943, 1.4960298033497381, 1.7874830712148704, 2.077919056781362, 2.366569058746212, 2.6526552856580254, 2.9353919910837565, 3.2139865067710462, 3.4876401420039205, 3.7555488992447614, 4.0169039936858075, 4.2708920937444255, 4.516695246283391, 4.753490416083088, 4.980448573759619, 5.196733257816846, 5.401498534062363, 5.5938862695856075, 5.773022701203983, 5.938014243085913, 6.087942554026412, 6.22185898294719, 6.3387786050552855, 6.437674256526491, 6.517471173036333, 6.577043210547922, 6.6152119477182145, 6.630750482517514, 6.62239419502032, 6.588861232972003, 6.528885679614169, 6.44126645470282, 6.324934268258763, 6.179037488512264, 6.003045359557893, 5.796863231306212, 5.560950139178851, 5.2964242916307525, 5.005138540044673, 4.689706802924946, 4.353465384539611, 4.000360714989577, 3.634766498668355, 3.261246470517823, 2.8842903194195486, 2.50805663917773, 2.136155862833459, 1.7714983709554184, 1.4162204228081055, 1.0716870580678577, 0.7385598238849271, 0.416910246810664, 0.10635785274580735, -0.19378651733924795, -0.4843871203018495, -0.7663691283990112, -1.0406286554080715, -1.3079678257157648, -1.5690530004185268, -1.8243926942063686, -2.0743310476871732, -2.319052727440313, -2.5585955102954916, -2.792867421984311, -3.021665971843586, -3.2446976791680076, -3.461596667036367, -3.671941577834815, -3.8752704388343693, -4.071093378110213, -4.258903275779247, -4.438184546186777, -4.608420301800585, -4.769098166800212, -4.919714993492549, -5.059780711321534, -5.188821501200348, -5.306382454360866, -5.412029839930528, -5.505353076624592, -5.585966479629594, -5.6535108314643905, -5.707654815449579, -5.74809633432629, -5.774563729170936, -5.786816909510815, -5.784648400232128, -5.76788430677936, -5.736385200685785, -5.690046924779311, -5.6288013159099, -5.552616845471868, -5.461499173907442, -5.355491618388924, -5.234675534322074, -5.099170601915542, -4.949135024396824, -4.7847656318124425, -4.606297889319753, -4.414005815870068, -4.208201799224625, -3.9892363197523633, -3.75749757797497, -3.5134110258616897, -3.257438803762888, -2.990079085209691, -2.7118653226165983, -2.4233654157713547, -2.1251807820423534, -1.8179453478284726, -1.5023244586613838, -1.1790137142064558, -0.8487377346558477, -0.5122488630381172, -0.17032581474119177, 0.1762277179173436, 0.5265844932310413, 0.8798951653384405, 1.2352897294388177, 1.5918789452174624, 1.9487557116900873, 2.3049963603523715, 2.659661828145685, 3.01179864331988, 3.3604396885816508, 3.7046046296352166, 4.043299918508122, 4.375518241123943, 4.700237225616807, 5.016417220447093, 5.32299785713206, 5.618893048798261, 5.902984030134358, 6.174109850778247, 6.4310547557308295, 6.672531618644125, 6.89716059086405, 7.103441919448779, 7.289722102325166, 7.454152432342126, 7.594639682508432, 7.708789535706617, 7.793845151234046, 7.846626147480294, 7.863477762754846, 7.840246318942264, 7.77230532969407, 7.654665860129938, 7.4822121935518044, 7.250105029355803, 6.954381260106567, 6.592742989433486, 6.1654641509898465, 5.676257494115318, 5.13286567627598, 4.5471156799358186, 3.9342519315856386, 3.3115509179674705, 2.6964593306647267, 2.1046782763231486, 1.5486402118208102, 1.0366786173215197, 0.5729530911996037, 0.15798044483953227, -0.2104869194588456, -0.5364924433456603, -0.8250023732213795, -1.0812240522734538, -1.3101374875506617, -1.5162167744432034, -1.703298442142401, -1.8745515695989656, -2.0325110498827, -2.1791449385106927, -2.3159359140319573, -2.4439642769307524, -2.5639853375965003, -2.676497706615494, -2.781801318417151, -2.8800453957971106, -2.971267229927647, -3.055423041949443, -3.1324121725837117, -3.202095883545351, -3.264311793652067, -3.318884911505232, -3.36563602326359, -3.4043880585698334, -3.4349709163419955, -3.4572251344864062, -3.4710046958514136, -3.476179187841866, -3.4726354821467167, -3.4602790544193565, -3.439035033292796, -3.4088490417787245, -3.3696878773446293, -3.321540062124033, -3.2644162874856364, -3.1983497666309435, -3.1233965057939415, -3.0396355039219425, -2.9471688835252725, -2.846121955430209, -2.736643220341454, -2.618904309316067, -2.4930998624372194, -2.359447347136317, -2.218186817811173, -2.069580613822025, -1.9139130003907252, -1.7514897504183966, -1.582637668828734, -1.407704058677563, -1.2270561377214602, -1.041080390365613, -0.850181873758928, -0.6547834704917193, -0.45532509090750534, -0.25226282765103814, -0.04606806111016229, 0.16277347506631762, 0.3737626345356768, 0.5863879395138604, 0.8001265996851541, 1.0144455578502583, 1.228802640271211, 1.4426476670729211, 1.6554236147745236, 1.8665677868056814, 2.075512988922776, 2.28168873005021, 2.4845224055593556, 2.6834405053032926, 2.877869792649821, 3.0672385192781477, 3.250977563253469, 3.4285216166551074, 3.5993103610417174, 3.7627896038345714, 3.9184124300718004, 4.065640373831999, 4.203944591068592, 4.332807080525645, 4.451721966435184, 4.560196872748514, 4.657754427311796, 4.743933946316229, 4.818293349075526, 4.880411365793281, 4.929890104501978, 4.966358043380478, 4.989473513049625, 4.998928732082107, 4.994454411637742, 4.975824922407208, 4.942864013115866, 4.895450949520698, 4.8335269037792745, 4.757101341530936, 4.666258066321645, 4.561160505647218, 4.442055763850143, 4.309276940066905, 4.16324322737041, 4.004457385383237, 3.83350029300258, 3.651022548504011, 3.4577332013055497, 3.2543860906841617, 3.041764426517221, 2.8206645056956305, 2.591879567790256, 2.3561848545064845, 2.1143248124871907, 1.8670033432029012, 1.614877465337275, 1.3585548044102969, 1.0985946879551833, 0.8355125125340953, 0.5697867334083575, 0.3018676963388466, 0.03218747307652635, -0.23883014589043478, -0.5107602276677798, -0.7831684368002889, -1.0556042895608635, -1.3275962425714738, -1.5986485801107866, -1.8682400588963244, -2.135824088790142, -2.4008301941638237, -2.662666459246552, -2.9207226628998346, -3.174373837602765, -3.422984030748397, -3.6659100888021254, -3.90250533985949, -4.1321230933648945, -4.354119913086149, -4.567858648007858, -4.772711229721468, -4.96806124852989, -5.153306337961, -5.327860391755741, -5.491155637343191, -5.642644590062107, -5.781801901616452, -5.908126120270099, -6.021141369633369, -6.12039895364122, -6.205478895272017, -6.2759914040418785, -6.331578249699996, -6.371914121276306, -6.3967078716498795, -6.405703700305626, -6.398682251340883, -6.37546166994792, -6.335898509475399, -6.279888611700928, -6.207367866990818, -6.11831284928137, -6.012741554941518, -5.890713697491745, -5.752331206387496, -5.597738495188359, -5.4271226498518, -5.240713510307897, -5.038783668801858, -4.821648316585243, -4.589665031918363, -4.34323344810772, -4.082794792813702, -3.808831351006462, -3.5218658189379424, -3.222460556023036, -2.911216691090121, -2.5887732213750447, -2.2558059389903415, -1.9130263047111615, -1.5611802268775519, -1.2010467638358204, -0.8334367585111762, -0.4591914091440843, -0.0791807946935503, 0.3056976350347515, 0.6945205850269345, 1.08634043424182, 1.4801867204840355, 1.8750675561636814, 2.269970929180656, 2.6638658278530025, 3.0557031268705073, 3.4444161258172006, 3.8289206240941227, 4.208114357309635, 4.580875597651346, 4.946060622085116, 5.302499673933987, 5.648990929345041, 5.98429182590968, 6.307106888815238, 6.61607095279156, 6.909726322231788, 7.186492080361494, 7.444623240382066, 7.682156989790242, 7.896842962535478, 8.086054283660905, 8.24667674705525, 8.37497531341642, 8.46644125543569, 8.515631275806882, 8.516023657318298, 8.459938126434809, 8.338596119299373, 8.142433240984191, 7.861803284931873, 7.488206239250691, 7.016090774949577, 6.445083303345724, 5.782187975088395, 5.043192089982216, 4.252427222099942, 3.440402759565011, 2.639630677468241, 1.8798044459725327, 1.1838270437052436, 0.565762593899142, 0.030912422603139606, -0.4225508581412003, -0.8012644792696856, -1.1144167781190029, -1.37196905340393, -1.5834753539854265, -1.7574314107860587, -1.9010114772112943, -2.020051052563932, -2.119163665102183, -2.2019157259223885, -2.2710135681762194, -2.3284782199821503, -2.37579710277832, -2.414049761358974, -2.444008863400334, -2.466219545935637, -2.481060728024904, -2.488791898471543, -2.4895884713232386, -2.4835682962491386, -2.470811412658281, -2.451374696610223, -2.42530267534231, -2.3926354843229274, -2.353414703853775, -2.3076876264012363, -2.2555103650848016, -2.196950106785956, -2.132086731162578, -2.061013959857803, -1.9838401545564968, -1.9006888485001026, -1.8116990746892558, -1.717025536619169, -1.6168386524009524, -1.511324496731002, -1.4006846574935934, -1.2851360191034131, -1.1649104808593664, -1.04025462022901, -0.9114293002892602, -0.7787092293125869, -0.6423824752837339, -0.5027499332425801, -0.3601247658337492, -0.21483177835969147, -0.06720677801375778, 0.08240411003306276, 0.23364516091398185, 0.3861518051175287, 0.5395514089346544, 0.6934640888968506, 0.8475035423146848, 1.0012779321131375, 1.1543907661715533, 1.3064418129805058, 1.4570280469450294, 1.6057445981820746, 1.7521857286718003, 1.895945832615048, 2.0366204411428104, 2.1738072477028667, 2.307107154436208, 2.4361253232172637, 2.5604722439562355, 2.6797648235391116, 2.793627481283277, 2.9016932608681536, 3.00360496618063, 3.0990163067822905, 3.1875930593671598, 3.2690142669415323, 3.34297343632953, 3.409179769965392, 3.4673594155837635, 3.51725673397829, 3.5586355839840764, 3.5912806154605903, 3.6149985631329544, 3.6296195323007447, 3.6349982564521603, 3.6310153061215593, 3.617578234844585, 3.5946226211354753, 3.5621129870853636, 3.520043543549494, 3.468438746569689, 3.4073536155739554, 3.336873783963743, 3.257115258310417, 3.168223865122325, 3.0703743784060404, 2.963769332261058, 2.848637546381732, 2.725232392232747, 2.5938298450219297, 2.454726414610749, 2.308237004755205, 2.1546927913682095, 1.9944392025763742, 1.8278340744690398, 1.655246053469954, 1.477053300820523, 1.2936425032806402, 1.105408228930742, 0.9127525984001326, 0.7160852343164633, 0.5158234425910044, 0.31239255418709944, 0.10622635592868057, -0.10223246695087856, -0.3125319448764966, -0.5242105569420468, -0.7367971327172311, -0.9498109582197178, -1.1627621042482306, -1.3751519833447268, -1.5864741272833554, -1.7962151671850008, -2.0038559916689223, -2.208873053514378, -2.4107397942146402, -2.6089281565034206, -2.8029101571103787, -2.9921594956861575, -3.176153179827607, -3.354373150152173, -3.5263078931956957, -3.6914540331875383, -3.8493178969900153, -3.9994170469521735, -4.141281779670226, -4.27445658852915, -4.398501588555582, -4.512993902899652, -4.6175290090450485, -4.711722043783049, -4.795209065440026, -4.867648271270809, -4.928721168230814, -4.978133694832152, -5.015617291800649, -5.04092991881431, -5.053857014459053, -5.054212398741737, -5.041839112546783, -5.016610193688627, -4.978429385010234, -4.927231789576681, -4.862984412036023, -4.7856866798304685, -4.695370855565715, -4.592102385785195, -4.475980163454359, -4.347136716175021, -4.205738309496803, -4.05198497363117, -3.8861104377084357, -3.7083819899539936, -3.5191002478022515, -3.318598845915163, -3.1072440398512797, -2.8854342270626323, -2.653599383888688, -2.412200422476828, -2.1617284670079666, -1.90270405104315, -1.6356762423270184, -1.3612216920098743, -1.0799436128550925, -0.7924706954839048, -0.4994559617003367, -0.2015755628089219, 0.10047247166846196, 0.4059695260711407, 0.7141777238334723, 1.0243412752617902, 1.3356878356707602, 1.6474298594658823, 1.9587659330377516, 2.2688820687524895, 2.5769529239883027, 2.882142935659185, 3.1836073186776033, 3.48049289186184, 3.77193868090554, 4.057076235311234, 4.335029580623262, 4.604914734054119, 4.865838661086213, 5.116897564667447, 5.357174358439126, 5.585735169140725, 5.801624710212997, 6.003860310695987, 6.191424478432223, 6.363255856508855, 6.518238476615623, 6.655189437051239, 6.77284529820589, 6.8698478578629105, 6.944730493476808, 6.995906972752629, 7.021665551025639, 7.020172420118459, 6.989489801203225, 6.927615200114726, 6.832549277999859, 6.702399451874701, 6.535524453690964, 6.330720479757299, 6.087441677952985, 5.806036762101283, 5.487971112471793, 5.135992663367693, 4.754195578418048, 4.347941958107395, 3.923622700714016, 3.4882693965143643, 3.049064173789663, 2.612820764956933, 2.1855187051477034, 1.7719598073521459, 1.3755863966797777, 0.9984655379199273, 0.641412652525612, 0.3042098554542139};

//-----------------------------------------------
//---------- Data checks and generation
double max_error = 1.0e-3;

template<typename input_type>
double get_error(input_type iA, input_type iB){
	double error, div_error=10000, per_error=10000, order=0;
	double A = (double) iA;
	double B = (double) iB;
	int power;
	if(A<0) A = -A;
	if(B<0) B = -B;
	
	if (A>B) {
		div_error = A-B;
		if(B>10){
			power = (int) log10(B);
			order = pow(10,power);
			div_error = div_error/order;
		}
	}
	else {
		div_error = B-A;
		if(A>10){
			power = (int) log10(A);
			order = pow(10,power);
			div_error = div_error/order;
		}
	}
	
	if(div_error<per_error) error = div_error;
	else error = per_error;
	return(error);
}

size_t Compare_data(int *CPU_data, int *GPU_data, size_t size){
	size_t nErrors = 0;
	
	for(size_t i = 0; i<size; i++){
		for(size_t j = 0; j<size; j++){
			size_t pos = i*size + j;
			if(CPU_data[pos]!=GPU_data[pos]) {
				if(DEBUG_MODE && nErrors<20) {
					printf("Reference: %d; Tested: %d; pos:[%zu;%zu];\n", CPU_data[pos], GPU_data[pos], i, j);
				}
				nErrors++;
			}
		}
	}
	return(nErrors);
}

size_t Compare_data(int *CPU_data, int *GPU_data, size_t rows, size_t columns){
	size_t nErrors = 0;
	
	for(size_t i = 0; i<rows; i++){
		for(size_t j = 0; j<columns; j++){
			size_t pos = i*columns + j;
			if(CPU_data[pos]!=GPU_data[pos]) {
				nErrors++;
				if(DEBUG_MODE && nErrors<20) {
					printf("Error at [%zu|%zu] CPU=%d; GPU=%d;\n", i, j, CPU_data[pos], GPU_data[pos]);
				}
			}
		}
	}
	return(nErrors);
}

size_t Compare_data(size_t *CPU_data, size_t *GPU_data, size_t rows, size_t columns){
	size_t nErrors = 0;
	
	for(size_t i = 0; i<rows; i++){
		for(size_t j = 0; j<columns; j++){
			size_t pos = i*columns + j;
			if(CPU_data[pos]!=GPU_data[pos]) nErrors++;
		}
	}
	return(nErrors);
}

template <typename input_type>
size_t Compare_data(input_type *CPU_data, input_type *GPU_data, size_t size){
	size_t nErrors = 0;
	
	
	for(size_t f = 0; f<size; f++){
		double error = get_error(CPU_data[f], GPU_data[f]);
		if(error > max_error) nErrors++;
	}
	return(nErrors);
}

template <typename input_type>
size_t Compare_data_histograms(input_type *CPU_data, input_type *GPU_data, size_t size){
	size_t nErrors = 0;
	
	for(size_t i = 0; i<size; i++){
		if(CPU_data[i]!=GPU_data[i]) {
			nErrors++;
			long long int CPU = CPU_data[i];
			long long int GPU = GPU_data[i];
			long long int dif = CPU_data[i] - GPU_data[i];
			if(DEBUG_MODE) printf("Error in the histogram at %zu: CPU=%lld; GPU=%lld; difference=%lld;\n", i, CPU, GPU, dif);
		}
		
	}
	return(nErrors);
}

template<typename input_type>
int Generate_random(input_type *h_input, size_t size){
	for(size_t i = 0; i<size; i++){
		h_input[i] = rand() / (input_type)RAND_MAX;
	}
	return(0);
}

template<typename input_type>
int Generate_random(std::vector<input_type> *input){
	for(size_t i = 0; i<input->size(); i++){
		input->operator[](i) = rand() / (input_type)RAND_MAX;
	}
	return(0);
}

//---------------------------------------------------<




//---------------- Recurrent rate unit test
int test_recurrent_rate(size_t input_size, RQAdp threshold_low, RQAdp threshold_high, RQAdp threshold_step, int tau, int emb, Accrqa_Distance distance_type){
	std::vector<RQAdp> input_data(input_size, 0);
	Generate_random(&input_data);
	
	std::vector<RQAdp> threshold_list;
	for (RQAdp threshold = threshold_low; threshold < threshold_high; threshold = threshold + threshold_step) threshold_list.push_back(threshold);
	int nThresholds = (int) threshold_list.size(); 
	
	RQAdp *CPU_RR_result, *GPU_RR_result, *GPU_DET_RR_result, *GPU_LAM_RR_result;
	int RR_output_size = accrqa_RR_output_size_in_elements(1, 1, threshold_list.size());
	CPU_RR_result = new RQAdp[nThresholds];
	GPU_RR_result = new RQAdp[nThresholds];
	GPU_DET_RR_result = new RQAdp[nThresholds];
	GPU_LAM_RR_result = new RQAdp[nThresholds];

	int tau_values = tau;
	int emb_values = emb;
	Accrqa_Error error;
	
	if(DEBUG_MODE) printf("--> RR unit test: data size = %zu; Thresholds=%d; emb=%d; tau=%d;\n", input_size, nThresholds, emb, tau);
	
	//-------> GPU
	if(GPU_UNIT_TEST) {
		accrqa_RR(GPU_RR_result, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, threshold_list.data(), nThresholds, distance_type, PLT_NV_GPU, &error);
		if(DEBUG_MODE) {
			printf("---->ACCRQA Error (accrqa_RR_GPU):");
			accrqa_print_error(&error);
			printf("\n");
		}
	}
	
	//-------> CPU
	accrqa_RR(CPU_RR_result, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, threshold_list.data(), nThresholds, distance_type, PLT_CPU, &error);
	
	int nErrors = 0;
	if(CHECK) {
		nErrors = Compare_data(GPU_RR_result, CPU_RR_result, nThresholds);
		if(nErrors>0 || DEBUG_MODE){
			if(nErrors>0) printf("------> Errors detected:\n");
			for(size_t f=0; f<threshold_list.size(); f++){
				double CPU = CPU_RR_result[f];
				double GPU = GPU_RR_result[f];
				double dif = CPU - GPU;
				printf("RR: f=%zu; CPU:%e; GPU:%e; diff:%e \n", f, CPU, GPU, dif);
			}
		}
	}
	
	delete[] CPU_RR_result;
	delete[] GPU_RR_result;
	delete[] GPU_DET_RR_result;
	delete[] GPU_LAM_RR_result;
	return(nErrors);
}

int test_recurrent_rate_extended(size_t input_size, RQAdp threshold_low, RQAdp threshold_high, RQAdp threshold_step, int tau, int emb){
	std::vector<RQAdp> input_data(input_size, 0);
	Generate_random(&input_data);
	
	std::vector<RQAdp> threshold_list;
	for (RQAdp threshold = threshold_low; threshold < threshold_high; threshold = threshold + threshold_step) threshold_list.push_back(threshold);
	int nThresholds = (int) threshold_list.size(); 
	
	RQAdp *CPU_RR_result, *GPU_DET_RR_result, *GPU_LAM_RR_result;
	int RR_output_size = accrqa_RR_output_size_in_elements(1, 1, threshold_list.size());
	CPU_RR_result = new RQAdp[nThresholds];
	GPU_DET_RR_result = new RQAdp[nThresholds];
	GPU_LAM_RR_result = new RQAdp[nThresholds];

	int tau_values = tau;
	int emb_values = emb;
	Accrqa_Error error;
	
	if(DEBUG_MODE) printf("--> RR unit test: data size = %zu; Thresholds=%d; emb=%d; tau=%d;\n", input_size, nThresholds, emb, tau);
	
	//-------> CPU
	accrqa_RR(CPU_RR_result, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, threshold_list.data(), nThresholds, DST_MAXIMAL, PLT_CPU, &error);
	
	//-------> GPU LAM
	{
		RQAdp *output_GPU;
		int output_size = accrqa_LAM_output_size_in_elements(1, 1, 1, 1);
		output_GPU = new RQAdp[output_size];
		int vmin_values = 2;
		int calc_ENTR = 1;
		for(size_t th_idx = 0; th_idx < threshold_list.size(); th_idx++){
			RQAdp threshold_values = threshold_list[th_idx];
			accrqa_LAM(output_GPU, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, &vmin_values, 1, &threshold_values, 1, DST_MAXIMAL, calc_ENTR, PLT_NV_GPU, &error);
			GPU_LAM_RR_result[th_idx] = output_GPU[4];
			if(DEBUG_MODE) {
				printf("---->ACCRQA Error (accrqa_LAM_GPU):");
				accrqa_print_error(&error);
				printf("\n");
			}
		}
		delete[] output_GPU;
	}
	
	//-------> GPU DET
	{
		RQAdp *output_GPU;
		int output_size = accrqa_LAM_output_size_in_elements(1, 1, 1, 1);
		output_GPU = new RQAdp[output_size];
		int lmin_values = 2;
		int calc_ENTR = 1;
		for(size_t th_idx = 0; th_idx < threshold_list.size(); th_idx++){
			RQAdp threshold_values = threshold_list[th_idx];
			accrqa_DET(output_GPU, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, &lmin_values, 1, &threshold_values, 1, DST_MAXIMAL, calc_ENTR, PLT_NV_GPU, &error);
			GPU_DET_RR_result[th_idx] = output_GPU[4];
			if(DEBUG_MODE) {
				printf("---->ACCRQA Error (accrqa_DET_GPU):");
				accrqa_print_error(&error);
				printf("\n");
			}
		}
		delete[] output_GPU;
	}
	
	int nErrors = 0;
	if(CHECK) {
		nErrors += Compare_data(GPU_DET_RR_result, CPU_RR_result, nThresholds);
		if(nErrors>0 || DEBUG_MODE){
			if(nErrors>0) printf("------> Errors detected:\n");
			for(size_t f=0; f<threshold_list.size(); f++){
				double CPU = CPU_RR_result[f];
				double GPU = GPU_DET_RR_result[f];
				double dif = CPU - GPU;
				printf("DET: f=%zu; CPU:%e; GPU DET:%e; diff:%e \n", f, CPU, GPU, dif);
			}
		}
		nErrors += Compare_data(GPU_LAM_RR_result, CPU_RR_result, nThresholds);
		if(nErrors>0 || DEBUG_MODE){
			if(nErrors>0) printf("------> Errors detected:\n");
			for(size_t f=0; f<threshold_list.size(); f++){
				double CPU = CPU_RR_result[f];
				double GPU = GPU_LAM_RR_result[f];
				double dif = CPU - GPU;
				printf("LAM: f=%zu; CPU:%e; GPU LAM:%e; diff:%e \n", f, CPU, GPU, dif);
			}
		}
	}
	
	delete[] CPU_RR_result;
	delete[] GPU_DET_RR_result;
	delete[] GPU_LAM_RR_result;
	return(nErrors);
}


void unit_test_RR(){
	printf("\n== Recurrent rate unit test ==\n");
	int total_GPU_nErrors = 0, GPU_nErrors = 0;
	
	printf("  Recurrent rate with different number of thresholds:"); fflush(stdout);
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	for(int exp=1; exp<9; exp++){
		int nThresholds = (1<<exp);
		size_t size = 1000;
		int tau = 1;
		int emb = 1;
		Accrqa_Distance distance_type = DST_MAXIMAL;
		RQAdp threshold_low = 0.0;
		RQAdp threshold_high = 1.0;
		RQAdp threshold_step = 1.0/((double) nThresholds);
		GPU_nErrors = test_recurrent_rate(size, threshold_low, threshold_high, threshold_step, tau, emb, distance_type);
		total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
		if(GPU_nErrors==0) {
			printf("\033[1;32m.\033[0m");
		}
		else {
			printf("\033[1;31m.\033[0m");
		}
		fflush(stdout);
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	
	printf("  Recurrent rate with different sizes:"); fflush(stdout);
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	for(size_t s = 1014; s < 32768; s = s*2){
		int nThresholds = 10;
		size_t size = s;
		int tau = 1;
		int emb = 1;
		Accrqa_Distance distance_type = DST_MAXIMAL;
		RQAdp threshold_low = 0;
		RQAdp threshold_high = 1.0;
		RQAdp threshold_step = 1.0/((double) nThresholds);
		GPU_nErrors = test_recurrent_rate(size, threshold_low, threshold_high, threshold_step, tau, emb, distance_type);
		total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
		if(GPU_nErrors==0) {
			printf("\033[1;32m.\033[0m");
		}
		else {
			printf("\033[1;31m.\033[0m");
		}
		fflush(stdout);
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	printf("  Recurrent rate with different time steps and embeddings:"); fflush(stdout);
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	for(int tau = 1; tau < 6; tau++){
		for(int emb = 1; emb < 12; emb++){
			int nThresholds = 10;
			size_t size = 1000;
			Accrqa_Distance distance_type = DST_MAXIMAL;
			RQAdp threshold_low = 0.1;
			RQAdp threshold_high = 1.0;
			RQAdp threshold_step = 1.0/((double) nThresholds);
			GPU_nErrors = test_recurrent_rate(size, threshold_low, threshold_high, threshold_step, tau, emb, distance_type);
			total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
			if(GPU_nErrors==0) {
				printf("\033[1;32m.\033[0m");
			}
			else {
				printf("\033[1;31m.\033[0m");
			}
			fflush(stdout);
		}
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	printf("  Recurrent rate with different distance types:\n"); fflush(stdout);
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	for(int distance_type=1; distance_type<=2; distance_type++){
		if(distance_type==DST_EUCLIDEAN) printf("    DST_EUCLIDEAN: ");
		else if(distance_type==DST_MAXIMAL) printf("    DST_MAXIMAL: ");
		else printf("Unknown metric!\n");
		for(int tau = 1; tau < 6; tau++){
			for(int emb = 1; emb < 12; emb++){
				int nThresholds = 10;
				size_t size = 1000;
				RQAdp threshold_low = 0.1;
				RQAdp threshold_high = 1.0;
				RQAdp threshold_step = 1.0/((double) nThresholds);
				GPU_nErrors = test_recurrent_rate(size, threshold_low, threshold_high, threshold_step, tau, emb, (Accrqa_Distance) distance_type);
				total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
				if(GPU_nErrors==0) {
					printf("\033[1;32m.\033[0m");
				}
				else {
					printf("\033[1;31m.\033[0m");
				}
				fflush(stdout);
			}
		}
		printf("\n");
	}
	if(total_GPU_nErrors==0) printf("      Test:\033[1;32mPASSED\033[0m\n");
	else printf("      Test:\033[1;31mFAILED\033[0m\n");
	printf("----------------------------------<\n");
}

void unit_test_RR_extended(){
	printf("\n== Recurrent rate through DET and LAM unit test ==\n");
	int total_GPU_nErrors = 0, GPU_nErrors = 0;
	
	printf("  Recurrent rate DET and LAM with different number of thresholds:"); fflush(stdout);
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	for(int exp=1; exp<9; exp++){
		int nThresholds = (1<<exp);
		size_t size = 1000;
		int tau = 1;
		int emb = 1;
		RQAdp threshold_low = 0.0;
		RQAdp threshold_high = 1.0;
		RQAdp threshold_step = 1.0/((double) nThresholds);
		GPU_nErrors = test_recurrent_rate_extended(size, threshold_low, threshold_high, threshold_step, tau, emb);
		total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
		if(GPU_nErrors==0) {
			printf("\033[1;32m.\033[0m");
		}
		else {
			printf("\033[1;31m.\033[0m");
		}
		fflush(stdout);
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	
	printf("  Recurrent rate DET and LAM with different sizes:"); fflush(stdout);
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	for(size_t s = 1014; s < 32768; s = s*2){
		int nThresholds = 10;
		size_t size = s;
		int tau = 1;
		int emb = 1;
		RQAdp threshold_low = 0;
		RQAdp threshold_high = 1.0;
		RQAdp threshold_step = 1.0/((double) nThresholds);
		GPU_nErrors = test_recurrent_rate_extended(size, threshold_low, threshold_high, threshold_step, tau, emb);
		total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
		if(GPU_nErrors==0) {
			printf("\033[1;32m.\033[0m");
		}
		else {
			printf("\033[1;31m.\033[0m");
		}
		fflush(stdout);
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	printf("  Recurrent rate using DET and LAM with different time steps and embeddings:"); fflush(stdout);
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	for(int tau = 1; tau < 6; tau++){
		for(int emb = 1; emb < 12; emb++){
			int nThresholds = 10;
			size_t size = 1000;
			RQAdp threshold_low = 0.1;
			RQAdp threshold_high = 1.0;
			RQAdp threshold_step = 1.0/((double) nThresholds);
			GPU_nErrors = test_recurrent_rate_extended(size, threshold_low, threshold_high, threshold_step, tau, emb);
			total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
			if(GPU_nErrors==0) {
				printf("\033[1;32m.\033[0m");
			}
			else {
				printf("\033[1;31m.\033[0m");
			}
			fflush(stdout);
		}
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	printf("----------------------------------<\n");
}
// ---------------------------------------------<


//---------------- DET and LAM unit test
int test_determinism(long int input_size, RQAdp threshold, int tau, int emb, int lmin, Accrqa_Distance distance_type){
	std::vector<RQAdp> input_data(input_size, 0);
	Generate_random(&input_data);
	
	// GPU
	RQAdp GPU_DET = 0, GPU_L = 0, GPU_Lmax = 0, GPU_ENTR = 0;
	
	int output_size = accrqa_LAM_output_size_in_elements(1, 1, 1, 1);
	int tau_values = tau;
	int emb_values = emb;
	RQAdp threshold_values = threshold;
	int lmin_values = lmin;
	int calc_ENTR = 0;
	Accrqa_Error error;
	
	if(GPU_UNIT_TEST) {
		RQAdp *output_GPU;
		output_GPU = new RQAdp[output_size];
		accrqa_DET(output_GPU, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, &lmin_values, 1, &threshold_values, 1, distance_type, calc_ENTR, PLT_NV_GPU, &error);
		GPU_DET  = output_GPU[0];
		GPU_L    = output_GPU[1];
		GPU_Lmax = output_GPU[2];
		GPU_ENTR = output_GPU[3];
		delete[] output_GPU;
	}
	
	// CPU
	RQAdp ref_DET = 0, ref_L = 0, ref_Lmax = 0, ref_ENTR = 0;
	{
		RQAdp *output_CPU;
		output_CPU = new RQAdp[output_size];
		accrqa_DET(output_CPU, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, &lmin_values, 1, &threshold_values, 1, distance_type, calc_ENTR, PLT_CPU, &error);
		ref_DET  = output_CPU[0];
		ref_L    = output_CPU[1];
		ref_Lmax = output_CPU[2];
		ref_ENTR = output_CPU[3];
		delete[] output_CPU;
	}
	
	int nErrors = 0;
	double ferror = 0;
	if(CHECK) {
		if(isnan(GPU_DET) && isnan(ref_DET)) ferror = 0;
		ferror = get_error(ref_DET, GPU_DET);
		if(ferror > max_error) nErrors++;
		if(DEBUG_MODE) printf("DET ref: %e; GPU: %e; diff: %e;\n", ref_DET, GPU_DET, ref_DET - GPU_DET);
		
		if(isnan(GPU_L) && isnan(ref_L)) ferror = 0;
		ferror = get_error(ref_L, GPU_L);
		if(ferror > max_error) nErrors++;
		if(DEBUG_MODE) printf("L ref: %e; GPU: %e; diff: %e;\n", ref_L, GPU_L, ref_L - GPU_L);
		
		if( calc_ENTR == 1) {
			if(isnan(GPU_Lmax) && isnan(ref_Lmax)) ferror = 0;
			ferror = get_error(ref_Lmax, GPU_Lmax);
			if(ferror > max_error) nErrors++;
			if(DEBUG_MODE) printf("TTmax ref: %e; GPU: %e; diff: %e;\n", ref_Lmax, GPU_Lmax, ref_Lmax - GPU_Lmax);
			
			if(isnan(GPU_ENTR) && isnan(ref_ENTR)) ferror = 0;
			ferror = get_error(ref_ENTR, GPU_ENTR);
			if(ferror > max_error) nErrors++;
			if(DEBUG_MODE) printf("ENTR ref: %e; GPU: %e; diff: %e;\n", ref_ENTR, GPU_ENTR, ref_ENTR - GPU_ENTR);
		}
	}
	return(nErrors);
}	

void unit_test_DET(){
	printf("\n== Determinism unit test ==\n");
	int total_GPU_nErrors = 0, GPU_nErrors = 0;

	std::vector<RQAdp> threshold_list;
	for(int t = 0; t <= 11; t++){
		threshold_list.push_back((RQAdp)t/10.0);
	}
	
	printf("  Determinism with different number of thresholds:"); fflush(stdout);
	if(DEBUG_MODE) printf("\n");
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	for(int t = 0; t<(int)threshold_list.size(); t++){
		RQAdp threshold = threshold_list[t];
		size_t size = 500;
		int tau = 1;
		int emb = 1;
		int lmin = 2;
		Accrqa_Distance distance_type = DST_MAXIMAL;
		if(DEBUG_MODE) printf("Testing with threshold=%f;\n", threshold);
		GPU_nErrors = test_determinism(size, threshold, tau, emb, lmin, distance_type);
		total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
		if(GPU_nErrors==0) {
			printf("\033[1;32m.\033[0m");
		}
		else {
			printf("\033[1;31m.\033[0m");
		}
		fflush(stdout);
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	printf("  Determinism with different input sizes:"); fflush(stdout);
	if(DEBUG_MODE) printf("\n");
	for(size_t s = 1014; s < 65538; s = s*2){
		for(int t = 0; t<(int)threshold_list.size(); t++){
			RQAdp threshold = threshold_list[t];
			int tau = 1;
			int emb = 1;
			int lmin = 2;
			Accrqa_Distance distance_type = DST_MAXIMAL;
			if(DEBUG_MODE) printf("Testing with size=%zu;\n", s);
			GPU_nErrors = test_determinism(s, threshold, tau, emb, lmin, distance_type);
			total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
			if(GPU_nErrors==0) {
				printf("\033[1;32m.\033[0m");
			}
			else {
				printf("\033[1;31m.\033[0m");
			}
			fflush(stdout);
		}
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	total_GPU_nErrors = 0; GPU_nErrors = 0;
	printf("  Determinism with different time steps and embeddings:"); fflush(stdout);
	if(DEBUG_MODE) printf("\n");
	for(int tau = 1; tau < 6; tau++){
		for(int emb = 1; emb < 12; emb++){
			for(int t = 0; t<(int)threshold_list.size(); t++){
				RQAdp threshold = threshold_list[t];
				size_t size = 1000;
				Accrqa_Distance distance_type = DST_MAXIMAL;
				if(DEBUG_MODE) printf("Testing with size=%zu, threshold=%f, tau=%d and emb=%d\n", size, threshold, tau, emb);
				int lmin = 2;
				GPU_nErrors = test_determinism(size, threshold, tau, emb, lmin, distance_type);
				total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
				if(GPU_nErrors==0) {
					printf("\033[1;32m.\033[0m");
				}
				else {
					printf("\033[1;31m.\033[0m");
				}
				fflush(stdout);
			}
		}
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	GPU_nErrors = 0; total_GPU_nErrors = 0;
	printf("  Determinism with different distance types:\n"); fflush(stdout);
	if(DEBUG_MODE) printf("\n");
	for(int distance_type=1; distance_type<=2; distance_type++){
		if(distance_type==DST_EUCLIDEAN) printf("    DST_EUCLIDEAN: ");
		else if(distance_type==DST_MAXIMAL) printf("    DST_MAXIMAL: ");
		else printf("Unknown metric!\n");
		for(int tau = 1; tau < 6; tau++){
			for(int emb = 1; emb < 12; emb++){
				RQAdp threshold = threshold_list[5];
				size_t size = 1000;
				if(DEBUG_MODE) printf("Testing with size=%zu, threshold=%f, tau=%d and emb=%d\n", size, threshold, tau, emb);
				int lmin = 2;
				GPU_nErrors = test_determinism(size, threshold, tau, emb, lmin, (Accrqa_Distance) distance_type);
				total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
				if(GPU_nErrors==0) {
					printf("\033[1;32m.\033[0m");
				}
				else {
					printf("\033[1;31m.\033[0m");
				}
				fflush(stdout);
			}
		}
		printf("\n");
	}
	if(total_GPU_nErrors==0) printf("      Test:\033[1;32mPASSED\033[0m\n");
	else printf("      Test:\033[1;31mFAILED\033[0m\n");
	printf("----------------------------------<\n");
}
// ---------------------------------------------<


//---------------- DET and LAM unit test
int test_laminarity(long int input_size, RQAdp threshold, int tau, int emb, int vmin, Accrqa_Distance distance_type){
	std::vector<RQAdp> input_data(input_size, 0);
	Generate_random(&input_data);
	
	int output_size = accrqa_LAM_output_size_in_elements(1, 1, 1, 1);
	int tau_values = tau;
	int emb_values = emb;
	RQAdp threshold_values = threshold;
	int vmin_values = vmin;
	int calc_ENTR = 0;
	Accrqa_Error error;
	
	RQAdp GPU_LAM, GPU_TT, GPU_TTmax;
	if(GPU_UNIT_TEST) {
		RQAdp *output_GPU;
		output_GPU = new RQAdp[output_size];
		accrqa_LAM(output_GPU, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, &vmin_values, 1, &threshold_values, 1, distance_type, calc_ENTR, PLT_NV_GPU, &error);
		GPU_LAM   = output_GPU[0];
		GPU_TT    = output_GPU[1];
		GPU_TTmax = output_GPU[2];
		delete[] output_GPU;
	}
	
	// Reference
	RQAdp ref_LAM, ref_TT, ref_TTmax;
	{
		RQAdp *output_CPU;
		output_CPU = new RQAdp[output_size];
		accrqa_LAM(output_CPU, input_data.data(), input_data.size(), &tau_values, 1, &emb_values, 1, &vmin_values, 1, &threshold_values, 1, distance_type, calc_ENTR, PLT_CPU, &error);
		ref_LAM   = output_CPU[0];
		ref_TT    = output_CPU[1];
		ref_TTmax = output_CPU[2];
		delete[] output_CPU;
	}
	
	//Potentially add histogram tests as well
	int nErrors = 0;
	double ferror = 0;
	if(CHECK) {
		if(isnan(GPU_LAM) && isnan(ref_LAM)) ferror = 0;
		else ferror = get_error(ref_LAM, GPU_LAM);
		if(ferror > max_error) nErrors++;
		if(DEBUG_MODE) printf("LAM ref: %e; GPU: %e; diff: %e;\n", ref_LAM, GPU_LAM, ref_LAM - GPU_LAM);
		
		if(isnan(GPU_TT) && isnan(ref_TT)) ferror = 0;
		else ferror = get_error(ref_TT, GPU_TT);
		if(ferror > max_error) nErrors++;
		if(DEBUG_MODE) printf("TT ref: %e; GPU: %e; diff: %e;\n", ref_TT, GPU_TT, ref_TT - GPU_TT);
		
		if(calc_ENTR==1){
			if(isnan(GPU_TTmax) && isnan(ref_TTmax)) ferror = 0;
			else ferror = get_error(ref_TTmax, GPU_TTmax);
			if(ferror > max_error) nErrors++;
			if(DEBUG_MODE) printf("TTmax ref: %e; GPU: %e; diff: %e;\n", ref_TTmax, GPU_TTmax, ref_TTmax - GPU_TTmax);
		}
	}
	return(nErrors);
}

void unit_test_LAM(void){
	printf("\n== Laminarity unit test ==\n");
	int total_GPU_nErrors = 0, GPU_nErrors = 0;
	
	std::vector<RQAdp> threshold_list;
	for(int t = 0; t <= 11; t++){
		threshold_list.push_back((RQAdp)t/10.0);
	}
	
	GPU_nErrors = 0; total_GPU_nErrors = 0;
	printf("  Laminarity with different number of thresholds:"); fflush(stdout);
	if(DEBUG_MODE) printf("\n");
	for(int t = 0; t<(int)threshold_list.size(); t++){
		RQAdp threshold = threshold_list[t];
		size_t size = 1000;
		int tau = 1;
		int emb = 1;
		int vmin = 2;
		Accrqa_Distance distance_type = DST_MAXIMAL;
		if(DEBUG_MODE) printf("Testing with threshold=%f;\n", threshold);
		GPU_nErrors = test_laminarity(size, threshold, tau, emb, vmin, distance_type);
		total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
		if(GPU_nErrors==0) {
			printf("\033[1;32m.\033[0m");
		}
		else {
			printf("\033[1;31m.\033[0m");
		}
		fflush(stdout);
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	
	GPU_nErrors = 0; total_GPU_nErrors = 0;
	printf("  Laminarity with different input sizes:"); fflush(stdout);
	if(DEBUG_MODE) printf("\n");
	for(size_t s = 1014; s < 32768; s = s*2){
		for(int t = 0; t<(int)threshold_list.size(); t++){
			RQAdp threshold = threshold_list[t];
			int tau = 1;
			int emb = 1;
			int vmin = 2;
			Accrqa_Distance distance_type = DST_MAXIMAL;
			if(DEBUG_MODE) printf("Testing with size=%zu and threshold=%f\n", s, threshold);
			GPU_nErrors = test_laminarity(s, threshold, tau, emb, vmin, distance_type);
			total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
			if(GPU_nErrors==0) {
				printf("\033[1;32m.\033[0m");
			}
			else {
				printf("\033[1;31m.\033[0m");
			}
			fflush(stdout);
		}
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");


	GPU_nErrors = 0; total_GPU_nErrors = 0;
	printf("  Laminarity with different time step and embedding:"); fflush(stdout);
	if(DEBUG_MODE) printf("\n");
	for(int tau = 1; tau < 6; tau++){
		for(int emb = 1; emb < 12; emb++){
			for(int t = 0; t<(int)threshold_list.size(); t++){
				size_t size = 1000;
				int vmin = 2;
				Accrqa_Distance distance_type = DST_MAXIMAL;
				RQAdp threshold = threshold_list[t];
				if(DEBUG_MODE) printf("Testing with size=%zu, threshold=%f, tau=%d and emb=%d \n", size, threshold, tau, emb);
				GPU_nErrors = test_laminarity(size, threshold, tau, emb, vmin, distance_type);
				total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
				if(GPU_nErrors==0) {
					printf("\033[1;32m.\033[0m");
				}
				else {
					printf("\033[1;31m.\033[0m");
				}
				fflush(stdout);
			}
		}
	}
	printf("\n");
	if(total_GPU_nErrors==0) printf("    Test:\033[1;32mPASSED\033[0m\n");
	else printf("    Test:\033[1;31mFAILED\033[0m\n");
	
	GPU_nErrors = 0; total_GPU_nErrors = 0;
	printf("  Laminarity with different distance types:\n"); fflush(stdout);
	if(DEBUG_MODE) printf("\n");
	for(int distance_type=1; distance_type<=2; distance_type++){
		if(distance_type==DST_EUCLIDEAN) printf("    DST_EUCLIDEAN: ");
		else if(distance_type==DST_MAXIMAL) printf("    DST_MAXIMAL: ");
		else printf("Unknown metric!\n");
		for(int tau = 1; tau < 6; tau++){
			for(int emb = 1; emb < 12; emb++){
				size_t size = 1000;
				int vmin = 2;
				RQAdp threshold = threshold_list[5];
				if(DEBUG_MODE) printf("Testing with size=%zu, threshold=%f, tau=%d and emb=%d \n", size, threshold, tau, emb);
				GPU_nErrors = test_laminarity(size, threshold, tau, emb, vmin, (Accrqa_Distance) distance_type);
				total_GPU_nErrors = total_GPU_nErrors + GPU_nErrors;
				if(GPU_nErrors==0) {
					printf("\033[1;32m.\033[0m");
				}
				else {
					printf("\033[1;31m.\033[0m");
				}
				fflush(stdout);
			}
		}
		printf("\n");
	}
	if(total_GPU_nErrors==0) printf("      Test:\033[1;32mPASSED\033[0m\n");
	else printf("      Test:\033[1;31mFAILED\033[0m\n");
	printf("----------------------------------<\n");
}
// ---------------------------------------------<




template <typename input_type>
inline double distance_euclidean(input_type *input, size_t i, size_t j, int tau, int emb){
	input_type sum = 0;
	for(int m = 0; m < emb; m++){
		input_type A = input[i + m*tau];
		input_type B = input[j + m*tau];
		sum += (A - B)*(A - B);
	}
	sum = sqrt(sum);
	return(sum);
}


template <typename input_type>
inline double distance_maximum(input_type *input, size_t i, size_t j, int tau, int emb){
	input_type max = 0;
	for(int m = 0; m < emb; m++){
		input_type A = input[i + (size_t) (m*tau)];
		input_type B = input[j + (size_t) (m*tau)];
		input_type dist = abs(A - B);
		if(dist > max) max = dist;
	}
	return(max);
}

template <typename input_type>
int R_matrix_element(input_type *input, size_t i, size_t j, input_type threshold, int tau, int emb, int distance_type){
	input_type distance = 0;
	if(distance_type == 1) distance = distance_euclidean(input, i, j, tau, emb);
	if(distance_type == 2) distance = distance_maximum(input, i, j, tau, emb);
	int R_element = ( (threshold - distance)>=0 ? 1 : 0 );
	//printf("[%d;%d]=%d; ", (int) i, (int) j, R_element);
	return ( R_element );
}



size_t calculate_k(size_t last_block_end){
	if(last_block_end == 0) return (0);
	double a = 1.0;
	double b = 1.0; // always positive
	double c = -2.0*last_block_end; // always negative
	double D = 1.0 - 4.0*a*c;
	double n1 = (sqrt(D)-1.0)/2.0;
	return( (size_t) n1);
}

void calculate_coordinates(size_t *i, size_t *j, size_t pos, size_t corrected_size){
	size_t pk = calculate_k(pos);
	*i = pos - (pk*(pk-1))/2 - pk;
	*j = corrected_size - pk - 1 + *i;
}


size_t test_coordinates(size_t corrected_size){
	size_t nErrors = 0;
	std::vector<size_t> msizes;
	for(size_t f=1; f<corrected_size; f++) msizes.push_back(f);
	std::vector<size_t> mscan;
	mscan.push_back(0);
	for(size_t f=0; f<=corrected_size; f++) mscan.push_back(mscan[f] + msizes[f]);
	for(size_t f=0; f<corrected_size-1; f++) {
		size_t i, j;
		calculate_coordinates(&i, &j, mscan[f], corrected_size);
		if(i != 0 || j != corrected_size-1-f) nErrors++;
	}
	return(nErrors);
}


template <typename input_type>
size_t test_indexing(input_type *time_series, size_t data_size, input_type threshold, int tau, int emb, int distance_type){
	size_t corrected_size = data_size - (emb - 1)*tau;
	size_t nErrors = 0;
	std::vector<int> linearised_R_matrix;
	for (size_t r = corrected_size-1; r>0; r--) {
		size_t distance_from_diagonal = r;
		size_t diagonal_length = corrected_size-distance_from_diagonal;
		for(size_t s=0; s<diagonal_length; s++) {
			long int row = s;
			long int column = s + distance_from_diagonal;
			int R_matrix_value = R_matrix_element(time_series, row, column, threshold, tau, emb, distance_type);
			linearised_R_matrix.push_back(R_matrix_value);
		}
	}
	
	size_t block_size = 1024;
	size_t total_elements = ((corrected_size-1)*corrected_size)/2;
	size_t nBlocks = (total_elements + block_size - 1)/block_size;
	for(size_t b=0; b<nBlocks; b++){
		for(size_t th_id = 0; th_id < block_size; th_id++){
			size_t pos = b*block_size + th_id;
			if(pos < total_elements){
				size_t i, j;
				calculate_coordinates(&i, &j, pos, corrected_size);
				int R_matrix_value = R_matrix_element(time_series, i, j, threshold, tau, emb, distance_type);
				if(R_matrix_value != linearised_R_matrix[pos]) {
					if(nErrors < 20 ){
						printf("th_id = %zu; b=%zu; pos=%zu; i = %zu; j = %zu;\n", th_id, b, pos, i, j);
						printf("%d != %d;\n", R_matrix_value, linearised_R_matrix[pos]);
					}
					nErrors++;
				}
			}
		}
	}
	
	return(nErrors);
}


void init_index_testing(){
	int tau = 1;
	int emb = 1;
	int lmin = 2;
	size_t data_size = 10;
	
	{
		size_t nErrors = 0;
		printf("Test of coordinate calculation: ");
		for(size_t s = 10; s <= 100; s=s*10){
			nErrors += test_coordinates(s);
		}
		if(nErrors>0) {
			printf("\033[1;31mFAILED\033[0m with number of errors = %zu;\n", nErrors);
		}
		else printf("\033[1;32mPASSED\033[0m\n");
	}
	
	std::vector<RQAdp> threshold_list;
	for(int t = 0; t <= 11; t++){
		threshold_list.push_back((RQAdp)t/10.0);
	}
	
	for(int s = 10; s <= 10000; s=s*10){
		size_t nErrors = 0;
		std::vector<RQAdp> input_data(s, 0);
		Generate_random(&input_data);
		printf("Test of regularized indexing at size %d: ", s); fflush(stdout);
		for(size_t t = 0; t<threshold_list.size(); t++){
			nErrors += test_indexing(input_data.data(), input_data.size(), threshold_list[t], tau, emb, DST_MAXIMAL);
		}
		input_data.clear();
		if(nErrors>0) {
			printf("\033[1;31mFAILED\033[0m with number of errors = %zu;\n", nErrors);
		}
		else printf("\033[1;32mPASSED\033[0m\n");
	}
}

void add_line(std::vector<int> *matrix, int lenght){
	matrix->push_back(0);
	for(int f=0; f<lenght;f++){
		matrix->push_back(1);
	}
}

void delete_lines(std::vector<int> *matrix, int lenght){
	size_t size = matrix->size();
	for(size_t f=0;f<size;f++){
		int sum = 0;
		for(size_t l=0; l<lenght && (f+l)<size;l++){
			sum += matrix->operator[](f+l);
		}
		matrix->operator[](f) = (int) (sum/(lenght));
	}
}

void print_line(std::vector<int> matrix){
	size_t size = matrix.size();
	for(size_t f=0;f<size;f++){
		printf("%d ", matrix[f]);
	}
	printf("\n");
}

int sum_line(std::vector<int> matrix){
	size_t size = matrix.size();
	int sum = 0;
	for(size_t f=0;f<size;f++){
		sum += matrix[f];
	}
	return(sum);
}

void apply_filter(std::vector<int> *matrix, int length){
	size_t size = matrix->size();
	for(size_t f=0;f<size-1;f++){
		if(f==0 && matrix->operator[](f)==1){
			matrix->operator[](f) = length;
		}
		else {
			if(matrix->operator[](f) == 0 && matrix->operator[](f+1) == 1){
				matrix->operator[](f+1) = length;
			}
		}
	}
}

void test_delete_lines(){
	printf("Testing line deletion and sum correction: ");
	fflush(stdout);
	std::vector<int> matrix;
	std::vector<int> lengths={1,2,1,2,3,4,2,1,4,4,5,7,9};
	for(size_t f=0; f<lengths.size(); f++){
		add_line(&matrix, lengths[f]);
	}
	int sum_before = sum_line(matrix);
	delete_lines(&matrix, 2);
	int sum_deleted = sum_line(matrix);
	apply_filter(&matrix, 2);
	int sum_corrected = sum_line(matrix);
	if(sum_before != 45 || sum_deleted != 32 || sum_corrected != 42) {
		printf("\033[1;31mFAILED\033[0m\n");
	}
	else {
		printf("\033[1;32mPASSED\033[0m\n");
	}
}

void test_starting_point(){
	int block_size = 1024;
	int lmin = 2;
	int start_overlap = 1;
	int nElements = block_size - lmin + 1 - 1;
	
	for(int f=0; f<10; f++){
		int global_pos = f*nElements;
		int start = global_pos;
		int end = global_pos + block_size - lmin;
	}
}

int compare_CRQA_DET_results(
	double CRQA_DET, double accrqa_DET,
	double CRQA_L, double accrqa_L,
	double CRQA_ENTR, double accrqa_ENTR,
	double CRQA_RR, double accrqa_RR,
	double error_tolerance
){
	int nErrors = 0;
	if(abs(CRQA_DET-accrqa_DET)   > error_tolerance) {nErrors++; printf("Error in CRQA comparison: CRQA DET = %f while accrqa DET = %f;\n", CRQA_DET, accrqa_DET);}
	if(abs(CRQA_L-accrqa_L)       > error_tolerance) {nErrors++; printf("Error in CRQA comparison: CRQA L = %f while accrqa L = %f;\n", CRQA_L, accrqa_L);}
	if(abs(CRQA_ENTR-accrqa_ENTR) > error_tolerance) {nErrors++; printf("Error in CRQA comparison: CRQA ENTR = %f while accrqa ENTR = %f;\n", CRQA_ENTR, accrqa_ENTR);}
	if(abs(CRQA_RR-accrqa_RR)     > error_tolerance) {nErrors++; printf("Error in CRQA comparison: CRQA RR = %f while accrqa RR = %f;\n", CRQA_RR, accrqa_RR);}
	return(nErrors);
}

int compare_CRQA_LAM_results(
	double CRQA_LAM, double accrqa_LAM,
	double CRQA_TT, double accrqa_TT,
	double CRQA_RR, double accrqa_RR,
	double error_tolerance
){
	int nErrors = 0;
	if(abs(CRQA_LAM-accrqa_LAM)   > error_tolerance) {nErrors++; printf("Error in CRQA comparison: CRQA LAM = %f while accrqa LAM = %f;\n", CRQA_LAM, accrqa_LAM);}
	if(abs(CRQA_TT-accrqa_TT)       > error_tolerance) {nErrors++; printf("Error in CRQA comparison: CRQA TT = %f while accrqa TT = %f;\n", CRQA_TT, accrqa_TT);}
	if(abs(CRQA_RR-accrqa_RR)     > error_tolerance) {nErrors++; printf("Error in CRQA comparison: CRQA RR = %f while accrqa RR = %f;\n", CRQA_RR, accrqa_RR);}
	return(nErrors);
}

int Run_CRQA_DET_comparison(int tau, int emb, int lmin, double thr, double CRQA_DET, double CRQA_L, double CRQA_ENTR, double CRQA_RR, Accrqa_Distance distance_type, double error_tolerance){
	double accrqa_DET_v, accrqa_L_v, accrqa_ENTR_v, accrqa_RR_v;
	int output_size = accrqa_LAM_output_size_in_elements(1, 1, 1, 1);
	double *output_CPU;
	output_CPU = new double[output_size];
	Accrqa_Error error;
	int nErrors = 0;
	accrqa_DET(output_CPU, test_timeseries, 1122, &tau, 1, &emb, 1, &lmin, 1, &thr, 1, distance_type, 1, PLT_CPU, &error);
	accrqa_DET_v  = output_CPU[0]; accrqa_L_v    = output_CPU[1]; accrqa_ENTR_v = output_CPU[3]; accrqa_RR_v   = output_CPU[4];
	nErrors += compare_CRQA_DET_results(CRQA_DET, accrqa_DET_v, CRQA_L, accrqa_L_v, CRQA_ENTR, accrqa_ENTR_v, CRQA_RR, accrqa_RR_v, error_tolerance);
	delete[] output_CPU;
	if(nErrors>0) return(1);
	else return(0);
}

int Run_CRQA_LAM_comparison(int tau, int emb, int vmin, double thr, double CRQA_LAM, double CRQA_TT, double CRQA_RR, Accrqa_Distance distance_type, double error_tolerance){
	double accrqa_LAM_v, accrqa_TT_v, accrqa_RR_v;
	int output_size = accrqa_LAM_output_size_in_elements(1, 1, 1, 1);
	double *output_CPU;
	output_CPU = new double[output_size];
	Accrqa_Error error;
	int nErrors = 0;
	accrqa_LAM(output_CPU, test_timeseries, 1122, &tau, 1, &emb, 1, &vmin, 1, &thr, 1, distance_type, 1, PLT_CPU, &error);
	accrqa_LAM_v  = output_CPU[0]; accrqa_TT_v    = output_CPU[1]; accrqa_RR_v   = output_CPU[4];
	nErrors += compare_CRQA_LAM_results(CRQA_LAM, accrqa_LAM_v, CRQA_TT, accrqa_TT_v, CRQA_RR, accrqa_RR_v, error_tolerance);
	delete[] output_CPU;
	if(nErrors>0) return(1);
	else return(0);
}

int Run_CRQA_RR_comparison(int tau, int emb, double thr, double CRQA_RR, Accrqa_Distance distance_type, double error_tolerance){
	double accrqa_RR_v;
	double output_CPU;
	Accrqa_Error error;
	int nErrors = 0;
	accrqa_RR(&output_CPU, test_timeseries, 1122, &tau, 1, &emb, 1, &thr, 1, distance_type, PLT_CPU, &error);
	accrqa_RR_v  = output_CPU;
	if(abs(CRQA_RR-accrqa_RR_v) > error_tolerance) {
		printf("Error in CRQA comparison: CRQA RR = %f while accrqa RR = %f;\n", CRQA_RR, accrqa_RR_v);
		return(1);
	}
	else {
		return(0);
	}
}

void test_against_CRQA_DET(){
	int tau, emb, lmin;
	double thr;
	Accrqa_Distance distance_type = DST_EUCLIDEAN;
	double CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR;
	int nErrors = 0;
	
	// CRQA comparison tests
	tau =  6; emb = 3; lmin = 2; thr = 1.2;CRQA_DET = 0.9988565, CRQA_L = 19.80633, CRQA_ENTR = 3.544372, CRQA_RR = 0.03407029;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau =  6; emb = 3; lmin = 2; thr = 1.8;CRQA_DET = 0.9991866, CRQA_L = 19.85697, CRQA_ENTR = 3.626616, CRQA_RR = 0.06585667;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau =  6; emb = 4; lmin = 2; thr = 1.2;CRQA_DET = 0.9991700, CRQA_L = 27.53370, CRQA_ENTR = 3.746358, CRQA_RR = 0.0218179;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau =  6; emb = 4; lmin = 2; thr = 1.8;CRQA_DET = 0.9992995, CRQA_L = 27.15812, CRQA_ENTR = 3.859276, CRQA_RR = 0.04216551;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 10; emb = 3; lmin = 2; thr = 1.2;CRQA_DET = 0.9993956, CRQA_L = 33.78207, CRQA_ENTR = 3.935241, CRQA_RR = 0.02452232;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 10; emb = 3; lmin = 2; thr = 1.8;CRQA_DET = 0.9994160, CRQA_L = 32.48800, CRQA_ENTR = 4.029226, CRQA_RR = 0.04794121;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 10; emb = 4; lmin = 2; thr = 1.2;CRQA_DET = 0.9996934, CRQA_L = 57.03790, CRQA_ENTR = 4.087776, CRQA_RR = 0.0164114;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 10; emb = 4; lmin = 2; thr = 1.8;CRQA_DET = 0.9998900, CRQA_L = 47.27430, CRQA_ENTR = 4.243792, CRQA_RR = 0.03136195;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	printf("Comparison with CRQA DET (Euclidiean norm): ");
	if(nErrors > 0) {
		printf("\033[1;31mFAILED\033[0m\n");
	}
	else {
		printf("\033[1;32mPASSED\033[0m\n");
	}
	
	nErrors = 0;
	distance_type = DST_MAXIMAL;
	tau = 6.00; emb = 3.0; lmin= 2.0; thr = 1.2; CRQA_DET= 0.9923518; CRQA_L = 19.79292; CRQA_ENTR = 3.447320; CRQA_RR = 0.04987582;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 3.0; lmin= 2.0; thr = 1.8; CRQA_DET= 0.9937105; CRQA_L = 21.81006; CRQA_ENTR = 3.560704; CRQA_RR = 0.0988475;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 4.0; lmin= 2.0; thr = 1.2; CRQA_DET= 0.9953496; CRQA_L = 28.71724; CRQA_ENTR = 3.727906; CRQA_RR = 0.03775631;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 4.0; lmin= 2.0; thr = 1.8; CRQA_DET= 0.9956827; CRQA_L = 30.98503; CRQA_ENTR = 3.834570; CRQA_RR = 0.07677615;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 3.0; lmin= 2.0; thr = 1.2; CRQA_DET= 0.9966764; CRQA_L = 29.19675; CRQA_ENTR = 3.680081; CRQA_RR = 0.03567676;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 3.0; lmin= 2.0; thr = 1.8; CRQA_DET= 0.9965360; CRQA_L = 32.35281; CRQA_ENTR = 3.826237; CRQA_RR = 0.07274186;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 4.0; lmin= 2.0; thr = 1.2; CRQA_DET= 0.9980198; CRQA_L = 40.91513; CRQA_ENTR = 3.755255; CRQA_RR = 0.02795053;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 4.0; lmin= 2.0; thr = 1.8; CRQA_DET= 0.9976886; CRQA_L = 48.25811; CRQA_ENTR = 4.157337; CRQA_RR = 0.05877578;
	nErrors += Run_CRQA_DET_comparison(tau, emb, lmin, thr, CRQA_DET, CRQA_L, CRQA_ENTR, CRQA_RR, distance_type, 1.e-4);

	
	printf("Comparison with CRQA DET (Maximal norm): ");
	if(nErrors > 0) {
		printf("\033[1;31mFAILED\033[0m\n");
	}
	else {
		printf("\033[1;32mPASSED\033[0m\n");
	}
}

void test_against_CRQA_LAM(){
	int tau, emb, vmin;
	double thr;
	Accrqa_Distance distance_type = DST_EUCLIDEAN;
	double CRQA_LAM, CRQA_TT, CRQA_RR;
	int nErrors = 0;
	
	// CRQA comparison tests
	tau = 6.00, emb = 3.0, vmin = 2.0, thr = 1.2, CRQA_LAM = 0.9957835, CRQA_TT = 6.887626, CRQA_RR = 0.03407029;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00, emb = 3.0, vmin = 2.0, thr = 1.8, CRQA_LAM = 0.9990018, CRQA_TT = 10.18866, CRQA_RR = 0.06585667;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00, emb = 4.0, vmin = 2.0, thr = 1.2, CRQA_LAM = 0.9915000, CRQA_TT = 5.775685, CRQA_RR = 0.0218179;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00, emb = 4.0, vmin = 2.0, thr = 1.8, CRQA_LAM = 0.9984823, CRQA_TT = 8.303236, CRQA_RR = 0.04216551;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0, emb = 3.0, vmin = 2.0, thr = 1.2, CRQA_LAM = 0.9944929, CRQA_TT = 6.333618, CRQA_RR = 0.02452232;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0, emb = 3.0, vmin = 2.0, thr = 1.8, CRQA_LAM = 0.9989694, CRQA_TT = 9.156171, CRQA_RR = 0.04794121;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0, emb = 4.0, vmin = 2.0, thr = 1.2, CRQA_LAM = 0.9943792, CRQA_TT = 5.366795, CRQA_RR = 0.0164114;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0, emb = 4.0, vmin = 2.0, thr = 1.8, CRQA_LAM = 0.9973800, CRQA_TT = 7.535354, CRQA_RR = 0.03136195;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	printf("Comparison with CRQA LAM (Euclidiean norm): ");
	if(nErrors > 0) {
		printf("\033[1;31mFAILED\033[0m\n");
	}
	else {
		printf("\033[1;32mPASSED\033[0m\n");
	}
	
	// CRQA comparison tests

	nErrors = 0;
	distance_type = DST_MAXIMAL;
	tau = 6.00; emb = 3.0; vmin = 2.0; thr = 1.2; CRQA_LAM = 0.9931003; CRQA_TT = 8.658910; CRQA_RR = 0.04987582;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 3.0; vmin = 2.0; thr = 1.8; CRQA_LAM = 0.9973889; CRQA_TT = 12.93356; CRQA_RR = 0.0988475;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 4.0; vmin = 2.0; thr = 1.2; CRQA_LAM = 0.9943935; CRQA_TT = 7.899189; CRQA_RR = 0.03775631;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 4.0; vmin = 2.0; thr = 1.8; CRQA_LAM = 0.9972749; CRQA_TT = 11.76216; CRQA_RR = 0.07677615;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 3.0; vmin = 2.0; thr = 1.2; CRQA_LAM = 0.9928680; CRQA_TT = 7.721594; CRQA_RR = 0.03567676;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 3.0; vmin = 2.0; thr = 1.8; CRQA_LAM = 0.9972379; CRQA_TT = 11.48852; CRQA_RR = 0.07274186;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 4.0; vmin = 2.0; thr = 1.2; CRQA_LAM = 0.9916292; CRQA_TT = 7.241674; CRQA_RR = 0.02795053;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 4.0; vmin = 2.0; thr = 1.8; CRQA_LAM = 0.9981024; CRQA_TT = 10.45196; CRQA_RR = 0.05877578;
	nErrors += Run_CRQA_LAM_comparison(tau, emb, vmin, thr, CRQA_LAM, CRQA_TT, CRQA_RR, distance_type, 1.e-4);
	printf("Comparison with CRQA LAM (Maximal norm): ");
	if(nErrors > 0) {
		printf("\033[1;31mFAILED\033[0m\n");
	}
	else {
		printf("\033[1;32mPASSED\033[0m\n");
	}
}

void test_against_CRQA_RR(){
	int tau, emb;
	double thr;
	double CRQA_RR;
	int nErrors = 0;
	Accrqa_Distance distance_type = DST_EUCLIDEAN;
	
	tau = 6.00; emb = 3.0; thr = 1.2; CRQA_RR = 0.03407029;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 3.0; thr = 1.8; CRQA_RR = 0.06585667;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 4.0; thr = 1.2; CRQA_RR = 0.0218179;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 4.0; thr = 1.8; CRQA_RR = 0.04216551;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 3.0; thr = 1.2; CRQA_RR = 0.02452232;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 3.0; thr = 1.8; CRQA_RR = 0.04794121;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 4.0; thr = 1.2; CRQA_RR = 0.0164114;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 4.0; thr = 1.8; CRQA_RR = 0.03136195;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	printf("Comparison with CRQA RR (Euclidiean norm): ");
	if(nErrors > 0) {
		printf("\033[1;31mFAILED\033[0m\n");
	}
	else {
		printf("\033[1;32mPASSED\033[0m\n");
	}
	
	
	nErrors = 0;
	distance_type = DST_MAXIMAL;
	tau = 6.00; emb = 3.0; thr = 1.2; CRQA_RR = 0.04987582;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 3.0; thr = 1.8; CRQA_RR = 0.0988475;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 4.0; thr = 1.2; CRQA_RR = 0.03775631;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 6.00; emb = 4.0; thr = 1.8; CRQA_RR = 0.07677615;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 3.0; thr = 1.2; CRQA_RR = 0.03567676;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 3.0; thr = 1.8; CRQA_RR = 0.07274186;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 4.0; thr = 1.2; CRQA_RR = 0.02795053;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	tau = 10.0; emb = 4.0; thr = 1.8; CRQA_RR = 0.05877578;
	nErrors += Run_CRQA_RR_comparison(tau, emb, thr, CRQA_RR, distance_type, 1.e-4);
	printf("Comparison with CRQA RR (Maximal norm): ");
	if(nErrors > 0) {
		printf("\033[1;31mFAILED\033[0m\n");
	}
	else {
		printf("\033[1;32mPASSED\033[0m\n");
	}
	
}








int main(void) {
	
	init_index_testing();
	test_delete_lines();
	test_starting_point();
	
	test_against_CRQA_DET();
	test_against_CRQA_LAM();
	test_against_CRQA_RR();
	
	unit_test_RR();
	unit_test_RR_extended();
	unit_test_DET();
	unit_test_LAM();
	
	return (0);
}

